/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { mockServerPool } from "../mock-server/MockServerPool";
import { BrowserUseClient } from "../../src/Client";

describe("Workflows", () => {
    test("listWorkflows", async () => {
        const server = mockServerPool.createServer();
        const client = new BrowserUseClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = {
            items: [
                {
                    id: "id",
                    name: "name",
                    description: "description",
                    variables: { key: "value" },
                    cost: "cost",
                    isArchived: true,
                    createdAt: "2024-01-15T09:30:00Z",
                },
            ],
            totalItems: 1,
            pageNumber: 1,
            pageSize: 1,
        };
        server.mockEndpoint().get("/workflows").respondWith().statusCode(200).jsonBody(rawResponseBody).build();

        const response = await client.workflows.listWorkflows();
        expect(response).toEqual({
            items: [
                {
                    id: "id",
                    name: "name",
                    description: "description",
                    variables: {
                        key: "value",
                    },
                    cost: "cost",
                    isArchived: true,
                    createdAt: "2024-01-15T09:30:00Z",
                },
            ],
            totalItems: 1,
            pageNumber: 1,
            pageSize: 1,
        });
    });

    test("createWorkflow", async () => {
        const server = mockServerPool.createServer();
        const client = new BrowserUseClient({ apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = { name: "name" };
        const rawResponseBody = {
            id: "id",
            projectId: "projectId",
            userId: "userId",
            name: "name",
            description: "description",
            s3Key: "s3Key",
            yamlDownloadUrl: "yamlDownloadUrl",
            variables: { key: "value" },
            cost: "cost",
            isArchived: true,
            generationStatus: "pending",
            generationError: "generationError",
            inputSchema: [{ key: "value" }],
            inputTemplate: { key: "value" },
            createdAt: "2024-01-15T09:30:00Z",
            updatedAt: "2024-01-15T09:30:00Z",
        };
        server
            .mockEndpoint()
            .post("/workflows")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.workflows.createWorkflow({
            name: "name",
        });
        expect(response).toEqual({
            id: "id",
            projectId: "projectId",
            userId: "userId",
            name: "name",
            description: "description",
            s3Key: "s3Key",
            yamlDownloadUrl: "yamlDownloadUrl",
            variables: {
                key: "value",
            },
            cost: "cost",
            isArchived: true,
            generationStatus: "pending",
            generationError: "generationError",
            inputSchema: [
                {
                    key: "value",
                },
            ],
            inputTemplate: {
                key: "value",
            },
            createdAt: "2024-01-15T09:30:00Z",
            updatedAt: "2024-01-15T09:30:00Z",
        });
    });

    test("getWorkflow", async () => {
        const server = mockServerPool.createServer();
        const client = new BrowserUseClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = {
            id: "id",
            projectId: "projectId",
            userId: "userId",
            name: "name",
            description: "description",
            s3Key: "s3Key",
            yamlDownloadUrl: "yamlDownloadUrl",
            variables: { key: "value" },
            cost: "cost",
            isArchived: true,
            generationStatus: "pending",
            generationError: "generationError",
            inputSchema: [{ key: "value" }],
            inputTemplate: { key: "value" },
            createdAt: "2024-01-15T09:30:00Z",
            updatedAt: "2024-01-15T09:30:00Z",
        };
        server
            .mockEndpoint()
            .get("/workflows/workflow_id")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.workflows.getWorkflow({
            workflow_id: "workflow_id",
        });
        expect(response).toEqual({
            id: "id",
            projectId: "projectId",
            userId: "userId",
            name: "name",
            description: "description",
            s3Key: "s3Key",
            yamlDownloadUrl: "yamlDownloadUrl",
            variables: {
                key: "value",
            },
            cost: "cost",
            isArchived: true,
            generationStatus: "pending",
            generationError: "generationError",
            inputSchema: [
                {
                    key: "value",
                },
            ],
            inputTemplate: {
                key: "value",
            },
            createdAt: "2024-01-15T09:30:00Z",
            updatedAt: "2024-01-15T09:30:00Z",
        });
    });

    test("deleteWorkflow", async () => {
        const server = mockServerPool.createServer();
        const client = new BrowserUseClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = {
            id: "id",
            projectId: "projectId",
            userId: "userId",
            name: "name",
            description: "description",
            s3Key: "s3Key",
            yamlDownloadUrl: "yamlDownloadUrl",
            variables: { key: "value" },
            cost: "cost",
            isArchived: true,
            generationStatus: "pending",
            generationError: "generationError",
            inputSchema: [{ key: "value" }],
            inputTemplate: { key: "value" },
            createdAt: "2024-01-15T09:30:00Z",
            updatedAt: "2024-01-15T09:30:00Z",
        };
        server
            .mockEndpoint()
            .delete("/workflows/workflow_id")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.workflows.deleteWorkflow({
            workflow_id: "workflow_id",
        });
        expect(response).toEqual({
            id: "id",
            projectId: "projectId",
            userId: "userId",
            name: "name",
            description: "description",
            s3Key: "s3Key",
            yamlDownloadUrl: "yamlDownloadUrl",
            variables: {
                key: "value",
            },
            cost: "cost",
            isArchived: true,
            generationStatus: "pending",
            generationError: "generationError",
            inputSchema: [
                {
                    key: "value",
                },
            ],
            inputTemplate: {
                key: "value",
            },
            createdAt: "2024-01-15T09:30:00Z",
            updatedAt: "2024-01-15T09:30:00Z",
        });
    });

    test("updateWorkflow", async () => {
        const server = mockServerPool.createServer();
        const client = new BrowserUseClient({ apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = {};
        const rawResponseBody = {
            id: "id",
            projectId: "projectId",
            userId: "userId",
            name: "name",
            description: "description",
            s3Key: "s3Key",
            yamlDownloadUrl: "yamlDownloadUrl",
            variables: { key: "value" },
            cost: "cost",
            isArchived: true,
            generationStatus: "pending",
            generationError: "generationError",
            inputSchema: [{ key: "value" }],
            inputTemplate: { key: "value" },
            createdAt: "2024-01-15T09:30:00Z",
            updatedAt: "2024-01-15T09:30:00Z",
        };
        server
            .mockEndpoint()
            .patch("/workflows/workflow_id")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.workflows.updateWorkflow({
            workflow_id: "workflow_id",
        });
        expect(response).toEqual({
            id: "id",
            projectId: "projectId",
            userId: "userId",
            name: "name",
            description: "description",
            s3Key: "s3Key",
            yamlDownloadUrl: "yamlDownloadUrl",
            variables: {
                key: "value",
            },
            cost: "cost",
            isArchived: true,
            generationStatus: "pending",
            generationError: "generationError",
            inputSchema: [
                {
                    key: "value",
                },
            ],
            inputTemplate: {
                key: "value",
            },
            createdAt: "2024-01-15T09:30:00Z",
            updatedAt: "2024-01-15T09:30:00Z",
        });
    });

    test("getWorkflowYamlPresignedUrl", async () => {
        const server = mockServerPool.createServer();
        const client = new BrowserUseClient({ apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = { sizeBytes: 1 };
        const rawResponseBody = { url: "url", method: "POST", fields: { key: "value" }, s3Key: "s3Key", expiresIn: 1 };
        server
            .mockEndpoint()
            .post("/workflows/workflow_id/yaml/presigned-url")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.workflows.getWorkflowYamlPresignedUrl({
            workflow_id: "workflow_id",
            sizeBytes: 1,
        });
        expect(response).toEqual({
            url: "url",
            method: "POST",
            fields: {
                key: "value",
            },
            s3Key: "s3Key",
            expiresIn: 1,
        });
    });

    test("executeWorkflow", async () => {
        const server = mockServerPool.createServer();
        const client = new BrowserUseClient({ apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = {};
        const rawResponseBody = { id: "id", workflowId: "workflowId", status: "pending" };
        server
            .mockEndpoint()
            .post("/workflows/workflow_id/execute")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.workflows.executeWorkflow({
            workflow_id: "workflow_id",
        });
        expect(response).toEqual({
            id: "id",
            workflowId: "workflowId",
            status: "pending",
        });
    });

    test("generateWorkflow", async () => {
        const server = mockServerPool.createServer();
        const client = new BrowserUseClient({ apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = { taskPrompt: "Go to github.com and search for browser-use" };
        const rawResponseBody = { workflowId: "workflowId", status: "status", message: "message" };
        server
            .mockEndpoint()
            .post("/workflows/workflow_id/generate")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.workflows.generateWorkflow({
            workflow_id: "workflow_id",
            taskPrompt: "Go to github.com and search for browser-use",
        });
        expect(response).toEqual({
            workflowId: "workflowId",
            status: "status",
            message: "message",
        });
    });

    test("getExecution", async () => {
        const server = mockServerPool.createServer();
        const client = new BrowserUseClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = {
            id: "id",
            workflowId: "workflowId",
            userId: "userId",
            status: "pending",
            startedAt: "2024-01-15T09:30:00Z",
            finishedAt: "2024-01-15T09:30:00Z",
            timeTaken: 1.1,
            llmsCost: "llmsCost",
            initCost: "initCost",
            totalCost: "totalCost",
            input: { key: "value" },
            output: { key: "value" },
            errors: { key: "value" },
            executionMetadata: { key: "value" },
            logsDownloadUrl: "logsDownloadUrl",
            createdAt: "2024-01-15T09:30:00Z",
        };
        server
            .mockEndpoint()
            .get("/workflows/executions/execution_id")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.workflows.getExecution({
            execution_id: "execution_id",
        });
        expect(response).toEqual({
            id: "id",
            workflowId: "workflowId",
            userId: "userId",
            status: "pending",
            startedAt: "2024-01-15T09:30:00Z",
            finishedAt: "2024-01-15T09:30:00Z",
            timeTaken: 1.1,
            llmsCost: "llmsCost",
            initCost: "initCost",
            totalCost: "totalCost",
            input: {
                key: "value",
            },
            output: {
                key: "value",
            },
            errors: {
                key: "value",
            },
            executionMetadata: {
                key: "value",
            },
            logsDownloadUrl: "logsDownloadUrl",
            createdAt: "2024-01-15T09:30:00Z",
        });
    });

    test("listWorkflowExecutions", async () => {
        const server = mockServerPool.createServer();
        const client = new BrowserUseClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = {
            items: [
                {
                    id: "id",
                    workflowId: "workflowId",
                    status: "pending",
                    startedAt: "2024-01-15T09:30:00Z",
                    finishedAt: "2024-01-15T09:30:00Z",
                    timeTaken: 1.1,
                    totalCost: "totalCost",
                    input: { key: "value" },
                    output: { key: "value" },
                    errors: { key: "value" },
                    createdAt: "2024-01-15T09:30:00Z",
                },
            ],
            totalItems: 1,
            pageNumber: 1,
            pageSize: 1,
        };
        server
            .mockEndpoint()
            .get("/workflows/workflow_id/executions")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.workflows.listWorkflowExecutions({
            workflow_id: "workflow_id",
        });
        expect(response).toEqual({
            items: [
                {
                    id: "id",
                    workflowId: "workflowId",
                    status: "pending",
                    startedAt: "2024-01-15T09:30:00Z",
                    finishedAt: "2024-01-15T09:30:00Z",
                    timeTaken: 1.1,
                    totalCost: "totalCost",
                    input: {
                        key: "value",
                    },
                    output: {
                        key: "value",
                    },
                    errors: {
                        key: "value",
                    },
                    createdAt: "2024-01-15T09:30:00Z",
                },
            ],
            totalItems: 1,
            pageNumber: 1,
            pageSize: 1,
        });
    });

    test("listAllExecutions", async () => {
        const server = mockServerPool.createServer();
        const client = new BrowserUseClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = {
            items: [
                {
                    id: "id",
                    workflowId: "workflowId",
                    status: "pending",
                    startedAt: "2024-01-15T09:30:00Z",
                    finishedAt: "2024-01-15T09:30:00Z",
                    timeTaken: 1.1,
                    totalCost: "totalCost",
                    input: { key: "value" },
                    output: { key: "value" },
                    errors: { key: "value" },
                    createdAt: "2024-01-15T09:30:00Z",
                },
            ],
            totalItems: 1,
            pageNumber: 1,
            pageSize: 1,
        };
        server
            .mockEndpoint()
            .get("/workflows/executions")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.workflows.listAllExecutions();
        expect(response).toEqual({
            items: [
                {
                    id: "id",
                    workflowId: "workflowId",
                    status: "pending",
                    startedAt: "2024-01-15T09:30:00Z",
                    finishedAt: "2024-01-15T09:30:00Z",
                    timeTaken: 1.1,
                    totalCost: "totalCost",
                    input: {
                        key: "value",
                    },
                    output: {
                        key: "value",
                    },
                    errors: {
                        key: "value",
                    },
                    createdAt: "2024-01-15T09:30:00Z",
                },
            ],
            totalItems: 1,
            pageNumber: 1,
            pageSize: 1,
        });
    });

    test("cancelExecution", async () => {
        const server = mockServerPool.createServer();
        const client = new BrowserUseClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = {
            id: "id",
            workflowId: "workflowId",
            userId: "userId",
            status: "pending",
            startedAt: "2024-01-15T09:30:00Z",
            finishedAt: "2024-01-15T09:30:00Z",
            timeTaken: 1.1,
            llmsCost: "llmsCost",
            initCost: "initCost",
            totalCost: "totalCost",
            input: { key: "value" },
            output: { key: "value" },
            errors: { key: "value" },
            executionMetadata: { key: "value" },
            logsDownloadUrl: "logsDownloadUrl",
            createdAt: "2024-01-15T09:30:00Z",
        };
        server
            .mockEndpoint()
            .patch("/workflows/executions/execution_id/cancel")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.workflows.cancelExecution({
            execution_id: "execution_id",
        });
        expect(response).toEqual({
            id: "id",
            workflowId: "workflowId",
            userId: "userId",
            status: "pending",
            startedAt: "2024-01-15T09:30:00Z",
            finishedAt: "2024-01-15T09:30:00Z",
            timeTaken: 1.1,
            llmsCost: "llmsCost",
            initCost: "initCost",
            totalCost: "totalCost",
            input: {
                key: "value",
            },
            output: {
                key: "value",
            },
            errors: {
                key: "value",
            },
            executionMetadata: {
                key: "value",
            },
            logsDownloadUrl: "logsDownloadUrl",
            createdAt: "2024-01-15T09:30:00Z",
        });
    });

    test("getExecutionLogs", async () => {
        const server = mockServerPool.createServer();
        const client = new BrowserUseClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { downloadUrl: "downloadUrl" };
        server
            .mockEndpoint()
            .get("/workflows/executions/execution_id/logs")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.workflows.getExecutionLogs({
            execution_id: "execution_id",
        });
        expect(response).toEqual({
            downloadUrl: "downloadUrl",
        });
    });
});
